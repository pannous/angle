//# https://github.com/WebAssembly/design/blob/master/Semantics.md
//# https://github.com/WebAssembly/design/blob/master/JS.md
//https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md

// https://cdn.rawgit.com/WebAssembly/sexpr-wasm-prototype/2bb13aa785be9908b95d0e2e09950b39a26004fa/demo/index.html
// https://cdn.rawgit.com/WebAssembly/wabt/e528a622caa77702209bf0c3654ca78456c41a52/demo/index.html
// https://github.com/Krovatkin/sexpr-wasm-prototype

// /opt/js/binaryen/test/spec/block.wast
// /opt/js/WAVM/Test/spec/block.wast
// /opt/wabt/third_party/testsuite/block.wast
// wasm-as add.wast > add.wasm
// wasm-dis add.wasm #> ok.wast
// wast2wasm add.wast -o add.wasm  #wabt

// BINARYEN tools:
// asm2wasm
// binaryen.js
// s2wasm
// wasm-as
// wasm-dis
// wasm-opt
// wasm-shell
// wasm.js


// WABT tools:
// wasm-interp
// wasm-wast -> wa
// wasm2wast
// wasmdump
// wasmopcodecnt
// wast-desugar
// wast2wasm


// https://medium.com/@MadsSejersen/webassembly-the-missing-tutorial-95f8580b08ba#.zb9jacn2b
// error: @0x00000008: bad wasm file version: 0xc (expected 0xd)

new Memory(memoryDescriptor)
//module=WebAssembly.Module()
//Wasm=WebAssembly
//Wasm.instantiateModule(load('test.wasm');
//Wasm.instantiateModule(new Uint8Array([ 0x00, 0x61, 0x73, 0x6d, 0x0b, 0x00, 0x00, 0x00 ]));// minimal 'module'
WebAssembly.Module(new Uint8Array([ 0x00, 0x61, 0x73, 0x6d, 0x0d, 0x00, 0x00, 0x00 ]))
var memory = new WebAssembly.Memory({initial:10, maximum:100});



/*
0x04 // the size of the section id
0x74 0x79 0x70 0x65 // “type”
0x07 // the size of the rest of the section
0x01 // the number of function signatures
0x40 // the kind of function
0x02 0x01 0x01 // the two input types (i32, i32)
0x01 0x01 // the single output type (i32)

0x08 // the size of the section id
0x66 0x75 0x6e 0x63 0x74 0x69 0x6f 0x6e // “function”
0x02 // the size of the rest of the section
0x01 // the number of functions
0x00 // References the type signature with index 0
code:
0x04 // the size of the section id
0x63 0x6f 0x64 0x65 // “code”
0x0a // the size of the rest of the section
0x01 // the number of function bodies
0x08 // size of the first function body
0x00 // number of local variables
0x14 0x00 // load first parameter onto the stack
0x14 0x01 // load second parameter onto the stack
0x40 // replace the two top values on the stack with their sum
0x09 0x01 // return one result (from the top of the stack)
export:
0x06 // the size of the section id
0x65 0x78 0x70 0x6f 0x72 0x74 // "export"
0x06 // the size of the rest of the section
0x01 // the number of exported functions
0x00 // reference to the 0th function
0x03 // the size of the name
0x73 0x75 0x6d // ‘sum’
*/
//Putting it all together
var bytecode = new Uint8Array([
  0x00, 0x61, 0x73, 0x6d, 0x0b, 0x00, 0x00, 0x00,
  0x04, 0x74, 0x79, 0x70, 0x65, 0x07, 0x01, 0x40,
  0x02, 0x01, 0x01, 0x01, 0x01, 0x08, 0x66, 0x75,
  0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x02, 0x01,
  0x00, 0x06, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74,
  0x06, 0x01, 0x00, 0x03, 0x73, 0x75, 0x6d, 0x04,
  0x63, 0x6f, 0x64, 0x65, 0x0a, 0x01, 0x08, 0x00,
  0x14, 0x00, 0x14, 0x01, 0x40, 0x09, 0x01
]);
var mod = Wasm.instantiateModule(bytecode)
mod.exports.sum(1, 2)


//call js from wasm:
/*
0x06 // the size of the section id
0x69 0x6d 0x70 0x6f 0x72 0x74 // “import”
0x0d // the size of the rest of the section
0x01 // number of functions to import
0x01 // the index of the signature
0x04 // the size of the module name
0x6d 0x61 0x74 0x68 // “math”
0x05 // the size of the function name
0x6c 0x6f 0x67 0x31 0x30 // “log10”

0x14 0x00 // load first variable (the first parameter) onto the stack
0x10 0x01 // load the i32 constant 1 onto the stack
0xaf // convert the top value from i32 to f64
0x89 // sum the two top f64 values
0x18 0x01 0x00 // call imported function 0 with 1 parameter
0x92 // round up to nearest integer
0xa0 // convert the f64 back to an i32
0x09 0x01 // return one value
*/
var bytecode = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x0b, 0x00, 0x00, 0x00,
    0x04, 0x74, 0x79, 0x70, 0x65, 0x0b, 0x02, 0x40,
    0x01, 0x04, 0x01, 0x01, 0x40, 0x01, 0x04, 0x01,
    0x04, 0x06, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74,
    0x0d, 0x01, 0x01, 0x04, 0x6d, 0x61, 0x74, 0x68,
    0x05, 0x6c, 0x6f, 0x67, 0x31, 0x30, 0x08, 0x66,
    0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x02,
    0x01, 0x00, 0x06, 0x65, 0x78, 0x70, 0x6f, 0x72,
    0x74, 0x09, 0x01, 0x00, 0x06, 0x64, 0x69, 0x67,
    0x69, 0x74, 0x73, 0x04, 0x63, 0x6f, 0x64, 0x65,
    0x10, 0x01, 0x0e, 0x00, 0x14, 0x00, 0x10, 0x01,
    0xaf, 0x89, 0x18, 0x01, 0x00, 0x92, 0xa0, 0x09,
    0x01
 ]);
 var mod = Wasm.instantiateModule(bytecode, { 'math': Math });
 mod.exports.digits(12345); // returns 5



// print 'hello world' via callback/import:export!
var bytecode = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x0b, 0x00, 0x00, 0x00,
    0x04, 0x74, 0x79, 0x70, 0x65, 0x09, 0x02, 0x40,
    0x00, 0x00, 0x40, 0x02, 0x01, 0x01, 0x00, 0x06,
    0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x0b, 0x01,
    0x01, 0x02, 0x69, 0x6f, 0x05, 0x70, 0x72, 0x69,
    0x6e, 0x74, 0x08, 0x66, 0x75, 0x6e, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x02, 0x01, 0x00, 0x06, 0x6d,
    0x65, 0x6d, 0x6f, 0x72, 0x79, 0x03, 0x01, 0x01,
    0x01, 0x06, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74,
    0x08, 0x01, 0x00, 0x05, 0x67, 0x72, 0x65, 0x65,
    0x74, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x0a, 0x01,
    0x08, 0x00, 0x10, 0x2b, 0x10, 0x0d, 0x18, 0x02,
    0x00, 0x04, 0x64, 0x61, 0x74, 0x61, 0x10, 0x01,
    0x2b, 0x0d, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c,
    0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21
 ]);

var memory = null;

function print(index, length) {
    var bytes = Array.prototype.slice.call(memory, index, index + length);
    var msg = bytes.map( byte=>String.fromCharCode(byte) ).join(''); // wtf
    console.log(msg);
}

var mod = Wasm.instantiateModule(bytecode, { 'io': { 'print': print } });
//memory = new Uint8Array(mod.exports.memory);
mod.exports.greet();
// hello world!

//Since the function we use to instantiate the module returns a reference to the contiguous memory, it is not available until after the module has loaded … and without access to the contiguous memory we cannot print anything.


fetch('hello_world.wasm') // Fetch the binary
  .then(response => response.arrayBuffer())
  .then(buffer => WebAssembly.compile(buffer)) // Get a Module from the buffer
  .then(module => {
    // Get an Instance of the Module
    const instance = new WebAssembly.Instance(module);
    document.getElementById("btn").addEventListener("click", function() {
            alert("count function result is : " + instance.exports.count());
        }, false);
  });
