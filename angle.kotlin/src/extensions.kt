package com.pannous.extensions
//package extensions

//import com.sun.org.apache.xerces.internal.dom.AttributeMap

import org.w3c.dom.*
import java.io.File
import java.io.StringBufferInputStream
import java.math.BigDecimal
import java.math.BigInteger
import java.net.HttpURLConnection
import java.net.URL
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardOpenOption
import java.util.*
import javax.xml.parsers.DocumentBuilderFactory
import kotlin.io.println
import kotlin.reflect.KCallable
import kotlin.reflect.KFunction
import kotlin.reflect.full.declaredMemberFunctions
import kotlin.reflect.full.declaredMemberProperties
import kotlin.reflect.full.declaredMembers
import kotlin.collections.mutableListOf as list
import kotlin.collections.mutableMapOf as map
import kotlin.io.println as puts

typealias map=Map<*,*>
typealias bool = Boolean
typealias Bool = Boolean
typealias int = Int
typealias string = String
typealias strings=MutableList<String>
typealias Strings=MutableList<String>
typealias Liste=MutableList<Any>
typealias Listo=MutableList<*> // use (l is List) !
//typealias Liste=MutableList<*> Nothing bad
//typealias <E> Liste<E>=MutableList<E>
//typealias list = Collection<Any>

//sealed class Extensions {

fun extensions(){
	// just so that this can be found with ctrl+O
}


// PROPERTY!
val String.size: Int
	get() {
		return this.length
	}
// lol ^^>> wtf
val Collection<*>.length: Int
	get() {
		return this.size
	}


object Extensions {
	init {
		// make assertions throw!!! also via -ea JVM option
		val loader = ClassLoader.getSystemClassLoader()// javaClass.classLoader
		loader.setDefaultAssertionStatus(true)
	}
}

//	fun resolve_home() = { path: String -> path.replace("~", System.getenv("HOME")) }
fun resolve_home(path: String): String {
	return path.replace("~", System.getenv("HOME"))
}

fun read(file: String): List<String> {
	var current = System.getProperty("user.dir")
	return File(resolve_home(file)).readLines()
}


fun readText(file: String): String {
	var current = System.getProperty("user.dir")
	return File(resolve_home(file)).readText()
}

fun append(file: String, line: String) {
	if (!exists(file))
		Files.write(Paths.get(resolve_home(file)), line.toByteArray(), StandardOpenOption.CREATE_NEW)
	else
		Files.write(Paths.get(resolve_home(file)), line.toByteArray(), StandardOpenOption.APPEND)
}

fun temp(file: String, lines: String) {
	Files.write(Paths.get(resolve_home(file)), lines.toByteArray(), StandardOpenOption.DELETE_ON_CLOSE)
}

fun write(file: String, lines: String, delete: Boolean = false) {
	if (delete) Files.deleteIfExists(Paths.get(file))
	Files.write(Paths.get(resolve_home(file)), lines.toByteArray(), StandardOpenOption.CREATE_NEW)
}

fun exists(file: String): Boolean {
	return Files.exists(Paths.get(file))
}

//val list= arrayOf()

operator fun Boolean.plus(element: Boolean): Boolean {
	return this or element
}

operator fun Boolean.times(element: Boolean): Boolean {
	return this and element
}

operator fun Boolean.minus(element: Boolean): Boolean {
	return this xor element
}

// ADD slice operator list[1..10]
operator fun <E> List<E>.get(range: IntRange): Collection<E> {
	return this.subList(range.first, range.last + 1)
}

operator fun <E> List<E>.get(range: Pair<Int, Int>): Collection<E> {
	return this.subList(range.first, range.second + 1)
}

// EXTENSION PROPERTY!!!
val <K, V> Map<K, V>.len: Int
	get() {
		return this.size
	}

fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {
	return { x -> f(g(x)) }
}
//val oddLength = compose(::isOdd, ::length)

// https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-function/index.html
fun <T> dir(func: KFunction<T>): Pair<String, List<String>> {
	val args = func.parameters.map { "" + it.name }.toList()
	return "params" to args
}

// https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html
//	println(members)
//[boundReceiver, caller, container, defaultCaller, descriptor, isBound, isExternal, isInfix, isInline, isOperator, isSuspend, name, signature, createConstructorCaller, createInstanceMethodCaller, createJvmStaticInObjectCaller, createStaticMethodCaller, equals, getArity, hashCode, toString, annotations, isAbstract, isAnnotationConstructor, isFinal, isOpen, parameters, returnType, typeParameters, visibility, call, callBy, invoke]

//class kotlin.reflect.jvm.internal.KTypeImpl
//class kotlin.reflect.jvm.internal.KClassImpl


/*
java.lang.UnsupportedOperationException: This class is an internal synthetic class generated by the Kotlin compiler, such as an anonymous class for a lambda, a SAM wrapper, a callable reference, etc. It's not a Kotlin class or interface, so the reflection library has no idea what declarations does it have. Please use Java reflection to inspect this class:
 */
fun dir(inspect: Any): List<String> {
	var members = inspect::class.members.map { it.name }.distinct()
	members += inspect::class.typeParameters.map { it.name }.distinct()
	members += inspect::class.constructors.map { it.name }.distinct()
	members += inspect::class.declaredMembers.map { it.name }.distinct()
	members += inspect::class.declaredMemberFunctions.map { it.name }.distinct()
	members += inspect::class.declaredMemberProperties.map { it.name }.distinct()
	members = members.distinct()
	println(inspect)
	println(inspect.javaClass)
	print(members)
//	o::class.supertypes.map { it.members.map{it.name}.distinct() }
	return members;
}

//operator fun Number.times

infix fun <T> List<T>.wow(more: List<T>): Set<T> {
	return this.union(more)
}

infix fun <T> Int.of(more: List<T>): T {
	return more[this]
}

// like a in {..} but returns code, not bool
/*
	if("a" in map) puts("a" of map)

 */
infix fun <K, V> Any.of(more: Map<K, V>): V? {
	if (this is KCallable<*>)
		puts("!!!" + this.name)
	if (this is KCallable<*>)
		return this.call(more) as V? // how? egal
	if (this is Function<*>)
		return this.run { more.first }
	return more[this as K]
}

fun <R : Any?> readPropery(instance: Any, propertyName: String): R {
	val clazz = instance.javaClass.kotlin
	@Suppress("UNCHECKED_CAST")
	return clazz.declaredMemberProperties.first { it.name == propertyName }.get(instance) as R
}

internal val <K, V> Map<K, V>.first: V?
	get() {
//public inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {
		return this.get(0 as K)
	}

// use [1]+[2]
//infix fun <T> List<T>.and(secList: List<T>): Set<T> {
//	return this.union(secList)
//}
//infix fun <T> List<T>.or(secList: List<T>): Set<T> {
//	return this.union(secList)
//}

fun <T> List<T>.unique(): List<T> {
	return this.distinct()
}
//List::[contains, addAll, clear, ensureCapacityInternal, rangeCheckForAdd, fastRemove, replaceAll, listIterator, batchRemove, removeAll, add, clone, iterator, removeRange, get, forEach, trimToSize, spliterator, toArray, indexOf, lastIndexOf, isEmpty, removeAt, remove, sort, readObject, elementData, rangeCheck, set, ensureExplicitCapacity, grow, removeIf, writeObject, ensureCapacity, retainAll, subList, outOfBoundsMsg, size, parallelStream, stream, hashCode, equals, toString, containsAll, modCount, hugeCapacity, calculateCapacity, subListRangeCheck, serialVersionUID, DEFAULT_CAPACITY, EMPTY_ELEMENTDATA, DEFAULTCAPACITY_EMPTY_ELEMENTDATA, MAX_ARRAY_SIZE]


// PROPERTY!
val Int.square: Number
	get() {
		return this * this
	}


//val Number.double: Number
//	get() {
//		return this*2 // why not?
//	}


val Number.square: Number
	get() {
		return this * this
//		if(this as Any is Boolean)
//			return if(this==true) 1 else  0
//		return this as Number * this as Number
	}

operator fun Map<*, *>.minus(other: Any): Map<*, *> {
	val neu = this.toMutableMap()
	if (other is Map<*, *>)
		for ((x, v) in other)
			neu.remove(x)
	if (other is Iterable<*>)
		for (x in other)
			neu.remove(x)
	neu.remove(other)
	return neu
}

// WHY??
operator fun Number.times(number: Number): Number {
	if (this is Double) return this * number as Double
	if (this is Long) return this * number as Long
	if (this is Short) return this * number as Short
	if (this is Byte) return this * number as Byte
	if (this is Float) return this * number as Float
	if (this is Int) return this * number as Int
//	if(this is Integer)return this*number as Integer
	if (this is BigDecimal) return this.multiply(number as BigDecimal) // why?
	if (this is BigInteger) return this * multiply(number as BigInteger)
//	return (this as BigDecimal).times(number as BigDecimal) // why recursive?
	throw Error("WHAT?")
//	if(this is Boolean)return this*number
}

//+a 	a.unaryPlus()

/*
// clutters Any root!
operator fun Any?.unaryPlus():Boolean{
	if (this == null) return false
	return when (this) {
		is Collection<*> -> !this.isEmpty()
		is Map<*,*> -> !this.isEmpty()
		is String -> !this.isBlank()
		is Boolean -> this==true
		is Int -> throw Error("MUST NOT BE")//this>0 //!! +7
		is Number -> this!=0
		else -> true
	}
	// if(+obj) puts("ok")
}
*/

operator fun Any?.not(): Boolean {
	if (this == null) return true
	return when (this) {
		is Collection<*> -> this.isEmpty()
		is Map<*, *> -> this.isEmpty()
		is String -> this.isBlank()
		is Boolean -> this == false
		is Char -> this == 0.toChar()
		is Number -> this == 0
		else -> false
	}
//	throw Error("too hacked"+this+" "+this.javaClass)
}

// WOW but dangerous!
//use a() instead of puts(a)  stupid hack!
//operator fun Any?.invoke(): Boolean {
//	puts("DEBUG: "+this)
//	return true
//}


infix fun <K, V> Map<K, V>.has(key: K): Boolean {
	return key in this
}
/*
useless toys:

infix fun Any.equals(other: Any): Boolean {
	return this==other
}

fun Any?.puts(a: Any) {
	println(a)
} USE THIS:
import kotlin.io.println as println
import kotlin.io.println as puts
*/

/*
	if (this == null) return false
	if(this is Array<*>) return ! this.isEmpty()
	if(this is Number)return this!=0
	throw Error("too hacked")
}
*/

fun size(x: Collection<*>) = x.size
fun length(x: Collection<*>) = x.size
fun length(x: MutableMap<*, *>) = x.size
fun length(x: String) = x.length
fun size(x: String) = x.length


operator fun Int.times(s: String): String {
	return s.repeat(this)
}

infix fun Char.or(maybe: Char): Any {
	if (this == 0.toChar()) return maybe
	else return this
}


infix fun <E> E?.or(other: E): E{
	if (!this) return other
	else return this!!
}

//
//
//infix fun Any?.or(other: Any): Any {
//	if (!this) return other
//	else return this!!
//}

fun puts(line: Any?) {
	println(line)
}


fun log(a: Any?) {
	println(a)
}

fun log(a: Any?,b: Any?) {
	print(a)
	print(b)
	println()
}

//
//fun log(vararg line: Any) {
//	for(l in line)
//		print(line)
//	println()
//}



fun blax(line: Array<out Any?>) {
	TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
}


fun download2(url: String): String {
	var url = URL(url);
	val connection = url.openConnection() as HttpURLConnection
	connection.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)")
	var x = 1
	while (x > 0) x = connection.inputStream.read();
	return "fa"
}

fun download(url: String): String {
	return URL(url).readText()
}
val wget= ::download

fun download_binary(url: String): ByteArray {
	var website = URL(url);
	return website.openStream().readBytes()
}

//class NodeListIterator: Iterator<Node>{
//	override fun hasNext(): Boolean {
//		return i<list.length
//	}
//
//	object i {
//
//	}
//
//	override fun next(): Node {
//		return list.item(i++)
//	}
//
//}

operator fun NamedNodeMap.iterator(): Iterator<Node>{
	var list=this
	var i=0;
	return object:Iterator<Node>{
		override fun hasNext(): Boolean {return i<list.length}
		override fun next(): Node {return list.item(i++)}
	}
}

operator fun NodeList.iterator(): Iterator<Node>{
	var list=this
	var i=0;
	return object:Iterator<Node>{
		override fun hasNext(): Boolean {return i<list.length}
		override fun next(): Node {return list.item(i++)}
	}
}

internal fun Node.toString(): Any? {
	return "NOT POSSIBLE"
}

internal operator fun NamedNodeMap.get(s: String): Node {
	return this.getNamedItem(s)
}


internal operator fun Document.get(s: String): NodeList {
	var list:NodeList = this.getElementsByTagName(s)
	return list
}

internal operator fun Element.get(s: String): NodeList {
	var list:NodeList = this.getElementsByTagName(s)
	return list
}


val Node.v:Any get() {
	return this.value
}

val Node.text:String get() {
	if(!!this.nodeValue)
		return this.nodeValue
	return this.textContent
}

val Node.value:Any get() {
	if(!!this.nodeValue)
		return this.nodeValue
	return this.textContent
}


internal operator fun Node.get(attribute: String): Node {
	for (c in this.childNodes)
		if(c.nodeName==attribute)return c
	if(!!this.attributes)
		if(!!this.attributes[attribute])
	 		return this.attributes[attribute]
	val child = this.childNodes.get(attribute)
	if(!!child)return child as Node
	throw Exception("Node "+this+" has no "+attribute)
}
class Nodelist:Vector<Node>(),NodeList{
	override fun item(p0: Int): Node {
		return this[p0]
	}

	override fun getLength(): Int {
		return this.size
	}

}


operator fun Node.plus(s: String): String {
	return this.toString()+s

}



internal operator fun Node.rangeTo(s: String):Nodelist {
	var list=Nodelist()
	for (n in this.childNodes)
		if(n.nodeName==s)
			list.add(n)
	return list
}


internal operator fun Node.iterator(): Iterator<Any?> {
	var list=this.childNodes
	var i=0;
	return object:Iterator<Node>{
		override fun hasNext(): Boolean {return i<list.length}
		override fun next(): Node {return list.item(i++)}
	}
}


internal operator fun NodeList.get(s: String): Any? {
	if(this.length==1){
		return this.item(0).get(s)
	}
//	var ns=listOf<Node>()
	for(n in this)
		if (n.nodeName==s)
			return s
   throw Exception("NodeList "+this+" has no "+s)
}

//operator fun String.equals(char:Char):Boolean{
//	As to defining equals as an extension function: no, YOU CAN'T DO IT because extensions are resolved statically and are shadowed by members (there's a similar question about toString). }
//data class Something(val a: String, val b: Any, val c: String) {
//	override fun toString(): String = a + b + c
//}



fun Xml(text: String): Document {
	if(text[0]=='/')return Xml(URL("file://"+text))
	return  DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(StringBufferInputStream(text))
}

fun Xml(api: URL): Document {
//		xmlDoc.documentElement.normalize()
	return  DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(api.toExternalForm())
}


//operator fun Node.plus(s: String): String {
//	return ""+this.text+""+s
//}